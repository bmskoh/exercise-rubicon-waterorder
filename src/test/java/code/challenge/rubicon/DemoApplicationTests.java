package code.challenge.rubicon;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;

import java.net.URI;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

import code.challenge.rubicon.model.WaterOrder;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class WaterOrderIntegrationTests {
	@LocalServerPort
	private int port;

	@Autowired
	private TestRestTemplate restTemplate;

	@Value("${tempcredential.username:farmer}")
	private String userName;
	@Value("${tempcredential.password:password}")
	private String password;

	private String baseUrl;

	@BeforeEach
	public void init() {
		this.baseUrl = "http://localhost:" + port + "/waterorders";
	}

	private TestRestTemplate getRestTemplate() {
		return this.restTemplate.withBasicAuth(this.userName, this.password);
	}

	private HttpEntity<WaterOrder> createHttpEntityWithFarmIdStartDateTime(String farmId, LocalDateTime startDateTime) {
		WaterOrder order = new WaterOrder("orderId1", farmId, startDateTime, Duration.ofHours(5),
				WaterOrder.OrderStatus.REQUESTED);

		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		HttpEntity<WaterOrder> request = new HttpEntity<>(order, headers);
		return request;
	}

	@Test
	@DisplayName("Add order and retrieve order with the given orderId.")
	public void testAddWaterOrder() throws Exception {
		String farmId = "AddRetrive";
		LocalDateTime startTime = LocalDateTime.now().plusDays(1);
		HttpEntity<WaterOrder> request = this.createHttpEntityWithFarmIdStartDateTime(farmId, startTime);

		ResponseEntity<WaterOrder> result = this.getRestTemplate().postForEntity(this.baseUrl, request,
				WaterOrder.class);

		assertThat(result.getStatusCodeValue()).isEqualTo(200);

		WaterOrder returnedWaterOrder = result.getBody();
		assertThat(returnedWaterOrder.getFarmId()).isEqualTo(farmId);
		assertThat(returnedWaterOrder.getStartDateTime()).isEqualTo(startTime);
		assertThat(returnedWaterOrder.getDuration()).isEqualTo(Duration.ofHours(5));

		assertThat(this.getRestTemplate()
				.getForObject(this.baseUrl + "/" + returnedWaterOrder.getOrderId(), WaterOrder.class).getOrderId())
						.isEqualTo(returnedWaterOrder.getOrderId());
	}

	@Test
	@DisplayName("Add order with past startDateTime and expect bad request error.")
	public void testAddWaterOrderWithPastStartTime() throws Exception {
		String farmdId = "farmIdPastTime";
		LocalDateTime startTime = LocalDateTime.now().minusHours(1);
		HttpEntity<WaterOrder> request = this.createHttpEntityWithFarmIdStartDateTime(farmdId, startTime);

		ResponseEntity<Map> result = this.getRestTemplate().postForEntity(this.baseUrl, request, Map.class);

		assertThat(result.getStatusCodeValue()).isEqualTo(400);

		// Response structure is complicated because it's directly generated by
		// Hibernate validator.
		Map<String, List<Map>> returnedWaterOrder = result.getBody();
		List<Map> errorMap = (List<Map>) returnedWaterOrder.get("errors");

		assertThat(errorMap.get(0).get("field")).isEqualTo("startDateTime");

		// Make another GET request to check the order is not placed.
		ResponseEntity<Map> emptyResponse = this.getRestTemplate().getForEntity(this.baseUrl + "?farmid=" + farmdId,
				Map.class);

		// Not found
		assertThat(emptyResponse.getStatusCodeValue()).isEqualTo(404);
		Map<String, String> errBody = emptyResponse.getBody();
		// Expect there's no order with the given farm id.
		assertThat(errBody.get("farmId")).contains("doesn't exist");
	}

	@Test
	@DisplayName("Add second order with overlapping delivery time with first order.")
	public void testAddWaterOrdersWithOverlappingTimes() throws Exception {
		String farmId = "OverlappingFarm";
		LocalDateTime startTime = LocalDateTime.now().plusDays(1);
		HttpEntity<WaterOrder> request = this.createHttpEntityWithFarmIdStartDateTime(farmId, startTime);

		this.getRestTemplate().postForEntity(this.baseUrl, request, WaterOrder.class);

		request = this.createHttpEntityWithFarmIdStartDateTime(farmId, startTime.plusHours(1));

		ResponseEntity<Map> errResult = this.getRestTemplate().postForEntity(this.baseUrl, request, Map.class);

		assertThat(errResult.getStatusCodeValue()).isEqualTo(400);

		Map<String, String> returnedWaterOrder = errResult.getBody();

		assertThat(returnedWaterOrder.get("CREATE")).contains("Delivery time of the new order overlaps existing order");
	}

	@Test
	@DisplayName("Add 2 orders with different farmid and retrive by one of the farmids")
	public void testAddWaterOrderAndGetByFarmId() throws Exception {
		String farmId = "FirstFarmId";
		HttpEntity<WaterOrder> request = this.createHttpEntityWithFarmIdStartDateTime(farmId,
				LocalDateTime.now().plusHours(1));

		ResponseEntity<Map> result = this.getRestTemplate().postForEntity(this.baseUrl, request, Map.class);
		assertThat(result.getStatusCodeValue()).isEqualTo(200);

		request = this.createHttpEntityWithFarmIdStartDateTime("SecondFarmId", LocalDateTime.now().plusHours(1));

		result = this.getRestTemplate().postForEntity(this.baseUrl, request, Map.class);
		assertThat(result.getStatusCodeValue()).isEqualTo(200);

		List<Map<String, String>> returnedOrders = this.getRestTemplate()
				.getForObject(this.baseUrl + "?farmid=" + farmId, new ArrayList<Map<String, String>>().getClass());

		assertThat(returnedOrders.size()).isEqualTo(1);
		assertThat(returnedOrders.get(0).get("farmId")).isEqualTo(farmId);
	}

	@Test
	@DisplayName("Add order and cancel it.")
	public void testAddWaterOrderAndCancel() throws Exception {
		String farmId = "AddCancel";
		LocalDateTime startTime = LocalDateTime.now().plusDays(1);
		HttpEntity<WaterOrder> request = this.createHttpEntityWithFarmIdStartDateTime(farmId, startTime);

		ResponseEntity<WaterOrder> result = this.getRestTemplate().postForEntity(this.baseUrl, request,
				WaterOrder.class);

		String createdOrderId = result.getBody().getOrderId();

		this.getRestTemplate().put(this.baseUrl + "/" + createdOrderId + "/cancellation", null);

		assertThat(
				this.getRestTemplate().getForObject(this.baseUrl + "/" + createdOrderId, WaterOrder.class).getStatus())
						.isEqualTo(WaterOrder.OrderStatus.CANCELLED);

	}

	@Test
	@DisplayName("Try to cancel order with orderId that doesn't exist.")
	public void testCancelNonExistingWaterOrder() throws Exception {
		String fakeOrderId = "NonExistingFake";

		this.getRestTemplate().put(this.baseUrl + "/" + fakeOrderId + "/cancellation", null);

		RequestEntity<?> rEntity = RequestEntity.put(new URI(this.baseUrl + "/" + fakeOrderId + "/cancellation"))
				.body(null);

		ResponseEntity<Map> response = this.getRestTemplate().exchange(rEntity, Map.class);
		assertThat(response.getStatusCodeValue()).isEqualTo(404);
		assertThat((String) response.getBody().get("orderId")).contains("doesn't exist");
	}
}
